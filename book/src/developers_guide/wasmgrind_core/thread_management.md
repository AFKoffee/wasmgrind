# Thread Management Utilities
Wasmgrind-Core provides two basic utilities for thread management in Wasmgrind: Thread-IDs and Conditional-Handles.

## Thread-ID Management
The following code snippet shows, how the generation and management of unique thread-ids is implemented in Wasmgrind.

```Rust
static THREAD_COUNTER: AtomicU32 = AtomicU32::new(0);

thread_local! {
    static THREAD_ID: Cell<Option<u32>> = const { Cell::new(None) }
}

pub fn next_available_thread_id() -> u32 {
    THREAD_COUNTER.fetch_add(1, Ordering::SeqCst)
}

pub fn thread_id() -> Result<u32, Error> {
    THREAD_ID.try_with(|maybe_thread_id| {
        if let Some(thread_id) = maybe_thread_id.get() {
            Ok(thread_id)
        } else {
            bail!("Error: Thread-ID has not been initialized!")
        }
    })?
}

pub fn set_thread_id(id: u32) -> Result<(), Error> {
    THREAD_ID.try_with(|maybe_thread_id| {
        if maybe_thread_id.get().is_some() {
            bail!("Thread id was already initialized!")
        } else {
            maybe_thread_id.replace(Some(id));
            Ok(())
        }
    })?
}
```

**Key Concepts:**
- **_A thread-local thread-id variable_**:  
This variable holds the ID of the current thread. It should be set by the parent thread immediately after creation and before any access to it. If the thread is the runner-thread, i.e. the thread that executes the user-given function, Wasmgrind needs to generate and set the ID manually before executing the function.
- **_One-Time Initialization_**:  
Thread-ids are only allowed to be initialized once. Attemts to set it a second time will throw an error. This prevents thread-ids from changing during execution.
- **_Thread ID Generation_**: Thread-IDs are generated by incrementing an atomic 32-bit unsigned integer. Therefore, thread-ids are _not_ reused during a single program run.

## Conditional Handles
The conditional handle is a structure, which makes it possible to wait for a value to be set before accessing it. It is a simple data structure defined like this:

```Rust
pub struct ConditionalHandle<T> {
    handle: Mutex<Option<T>>,
    barrier: Condvar,
}

impl<T> ConditionalHandle<T> {
    pub fn new() -> Self {
        Self {
            handle: Mutex::new(None),
            barrier: Condvar::new(),
        }
    }

    pub fn with_value(val: T) -> Self {
        Self {
            handle: Mutex::new(Some(val)),
            barrier: Condvar::new(),
        }
    }

    pub fn set_and_notify(&self, val: T) -> Result<(), Error> {
        match self.handle.lock() {
            Ok(mut maybe_val) => {
                *maybe_val = Some(val);
                self.barrier.notify_one();
                Ok(())
            }
            Err(_) => Err(anyhow!("ConditionalHandle Mutex was poisoned!")),
        }
    }

    pub fn take_when_ready(&self) -> Result<T, Error> {
        let mut val = match self.handle.lock() {
            Ok(val) => val,
            Err(_) => bail!("ConditionalHandle Mutex was poisoned!"),
        };

        while val.is_none() {
            val = match self.barrier.wait(val) {
                Ok(val) => val,
                Err(_) => bail!("ConditionalHandle Mutex was poisoned!"),
            };
        }

        if let Some(inner) = val.take() {
            Ok(inner)
        } else {
            Err(anyhow!(
                "Taken value was None: This should never happen as we sync this operation through a condition variable."
            ))
        }
    }
}
```

**Key Concepts:**
- **`set_and_notify`**: Replaces the wrapped value with the given one and notifies a thread that is waiting for this value.
- **`take_when_ready`**: Tries to retrieve the wrapped value from the structure and waits on the condition variable to be notified if the value is not yet set.
- **_Initialization_**:  
The structure can be initialized with or without having a value set. This is helpful in situations where the result to wait for is already present at initialization. In this case the user of the result will not have to wait upon calling `take_when_ready` because the value is ready immediately.
- **_Synchronization_**:  
The access to the value, which is wrapped by the structure is synchronized via a condition variable. The value can only be accessed via `take_when_ready` and this function waits for the value to be present. Therefore, the calling thread is forced to wait for the value.